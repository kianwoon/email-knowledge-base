from pydantic import BaseModel, Field, validator, ConfigDict
from typing import List, Optional, Dict, Any
from datetime import datetime
import uuid
from sqlalchemy.sql import func
from sqlalchemy.dialects.postgresql import JSONB # Use JSONB for PostgreSQL

# SQLAlchemy imports
from sqlalchemy import Column, String, Boolean, DateTime, JSON, Text
# Use PostgreSQL specific UUID type
from sqlalchemy.dialects.postgresql import UUID as PG_UUID 
# Import Base from the canonical definition in base_class
from app.db.base_class import Base 
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import Integer

# --- Base Models --- 

# Remove AccessRule model
# class AccessRule(BaseModel): ... 

# --- API Request Models --- 

class TokenCreateRequest(BaseModel):
    name: str = Field(..., min_length=1, max_length=100, description="User-friendly name for the token")
    description: Optional[str] = Field(None, max_length=500, description="Optional description for the token")
    sensitivity: str = Field(..., description="Sensitivity level, e.g., 'public', 'internal'") # TODO: Use Enum?
    # Change rules to list of strings
    allow_rules: Optional[List[str]] = Field(default_factory=list, description="List of rules that MUST ALL be met for access")
    deny_rules: Optional[List[str]] = Field(default_factory=list, description="List of rules where ANY match denies access")
    expiry_days: Optional[int] = None # Optional expiry in days
    # Embeddings are generated by backend, not provided in request
    expiry: Optional[datetime] = Field(None, description="Optional expiry date/time for the token")
    is_editable: bool = Field(True, description="Whether the token configuration can be edited after creation")

class TokenUpdateRequest(BaseModel):
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    sensitivity: Optional[str] = Field(None) # TODO: Use Enum?
    # Change rules to list of strings
    allow_rules: Optional[List[str]] = None # Updating rules will trigger backend embedding update
    deny_rules: Optional[List[str]] = None  # Updating rules will trigger backend embedding update
    expiry: Optional[datetime] = None
    is_editable: Optional[bool] = None
    # Cannot update is_active directly via API, managed internally based on expiry
    # Cannot update token_value
    is_active: Optional[bool] = None # Allow updating active status directly if needed

# NEW: Model for bundling tokens (Assuming bundling combines rules/embeddings appropriately - needs logic adjustment in route)
class TokenBundleRequest(BaseModel):
    token_ids: List[int] = Field(..., description="List of token IDs to bundle.", min_items=1)
    name: str = Field(..., min_length=1, max_length=100, description="Name for the new bundled token.")
    description: Optional[str] = Field(None, max_length=500, description="Optional description for the bundled token.")

# --- API Response Models --- 

class TokenResponse(BaseModel):
    id: int
    name: str
    description: Optional[str]
    sensitivity: str
    token_preview: str # e.g., "token_123...abc"
    owner_email: str
    created_at: datetime
    expiry: Optional[datetime]
    is_active: bool
    # Change rules to list of strings
    allow_rules: Optional[List[str]] = Field(default_factory=list)
    deny_rules: Optional[List[str]] = Field(default_factory=list)
    # Embeddings not included in standard response
    
    model_config = ConfigDict(
        from_attributes=True  # Use this instead of orm_mode for Pydantic v2
    )

# --- Token Export Model (for middleware consumption) --- 

class TokenExport(BaseModel):
    id: int # Changed to int to match TokenDB
    # token_value: str -> Should not be needed here if middleware verifies hash
    hashed_token: str = Field(..., description="Hashed token value for server-side verification")
    sensitivity: str = Field(..., description="Sensitivity level associated with the token")
    owner_email: str = Field(..., description="Email of the token owner")
    is_active: bool = Field(..., description="Whether the token is currently active (not expired, etc.)")
    # Change rules to list of strings
    allow_rules: List[str] = Field(default_factory=list)
    deny_rules: List[str] = Field(default_factory=list)
    # Embeddings are internal, not typically exported unless needed by middleware
    # For now, assume middleware only needs rules

    model_config = ConfigDict(
        from_attributes=True  # Use this instead of orm_mode for Pydantic v2
    )

# SQLAlchemy model for the 'tokens' table
class TokenDB(Base):
    __tablename__ = "tokens"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)
    name: Mapped[str] = mapped_column(String(100), index=True) 
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True) 
    hashed_token: Mapped[str] = mapped_column(String(255), unique=True, index=True) 
    owner_email: Mapped[str] = mapped_column(String(255), index=True) 
    sensitivity: Mapped[str] = mapped_column(String(50), nullable=False, default="public", index=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.now())
    expiry: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    # Add is_editable column definition
    is_editable: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    # Change rules columns to list of strings
    allow_rules: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True)
    deny_rules: Mapped[Optional[List[str]]] = mapped_column(JSONB, nullable=True)
    # Embeddings stored as JSONB (likely List[List[float]])
    allow_embeddings: Mapped[Optional[List[Any]]] = mapped_column(JSONB, nullable=True)
    deny_embeddings: Mapped[Optional[List[Any]]] = mapped_column(JSONB, nullable=True)
    
    def __repr__(self):
        return f"<TokenDB(id={self.id}, name='{self.name}', owner='{self.owner_email}')>"

# Model to return the full token value ONCE upon creation
class TokenCreateResponse(TokenResponse):
     token_value: str

# Model for internal validation of token value
class TokenValidationRequest(BaseModel):
    token_value: str

class TokenValidationResponse(BaseModel):
    is_valid: bool
    # token_data would use TokenExport, which now excludes embeddings
    token_data: Optional[TokenExport] = None # Return exported data if valid 